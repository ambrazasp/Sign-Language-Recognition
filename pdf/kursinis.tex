\documentclass{VUMIFInfKursinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{color}
\usepackage{tikz}
\usepackage{enumitem}
% \usepackage{hyperref}  % Nuorodų aktyvavimas
\usepackage{url}

\setenumerate{topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex}
\setitemize{topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex}

% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\department{Programų sistemų katedra}
\papertype{Kursinis darbas}
\title{Gestų kalbos atpažinimas naudojant internetinę kamerą}
\titleineng{Sign language recognition using web camera}
\status{3 kurso I grupės studentas}
\author{Pranciškus Ambrazas}
\supervisor{asist. Linas Petkevičius}
\date{Vilnius, \the\year}

% Nustatymai
% \setmainfont{Palemonas}   % Pakeisti teksto šriftą į Palemonas (turi būti įdiegtas sistemoje)
\bibliography{bibliografija} 

\begin{document}
\maketitle

\tableofcontents

\sectionnonum{Įvadas}

Daugiau nei 360 milijonų žmonių pasaulyje kenčia dėl klausos ir kalbos įvairių problemų, o daugiau nei 32 milijonai jų yra vaikai ir šis skaičius vis auga \cite{WhoInt}. Gestų kalba yra pagrindinis šių žmonių bendravimo įrankis. Tačiau reiktų pastebėti ir tai, jog dalis jų moka dalinai skaityti iš lūpų. Norint žmogui be šių ydų bendrauti su gestakalbiu (\textit{gestų kalba kalbantis žmogus}), o kartais net dviems gestakalbiams tarpusavyje, reikia vertėjo, kuris išverstų gestų kalbą į įprastinę ir atvirkščiai.

Kiekviena pasaulyje esanti kalba turi ir savo gestų kalbą. Tai reiškia, skiriasi tiek gestų kalbos gramatika, tiek netgi patys gestai. Pasaulyje randama net dialektų pagal regionus, ne tik pagal šalis. Amerikiečių anglų gestų kalba (\textit{toliau - ASL}) šnekančių žmonių pasaulyje priskaičiuojam nuo 500 tūkstančių iki netgi 2 milijonų vien tik Jungtinėse Amerikos Valstijose. Remiantis Census Bereau surinktais duomenimis, kuris domisi kalbų mažumomis, ASL yra pirmoji mažumos kalba, po „didžiojo ketverto“, kurį sudaro ispanų, italų, vokiečių ir prancūzų kalbos \cite{GUL}. Tad netgi bendraujant dviem žmonėms, mokantiems gestų kalbą neretai iškyla vertimo problema, todėl tenka ieškoti gestų vertimų. Paiešką šiuo metu galima atlikti atsižvelgiant į delno padėtį, vienos ar abiejų rankų judesį, jų padėtį ir gestą atliekančių rankų skaičių. Tuomet pagal gesto išvaizdos nuotraukas ar kartais net vaizdo įrašus, gestakalbiai gali išsiversti gestus. Tam yra skirtos tiek internetinės svetainės - žodynai, tiek įvairūs rašytiniai žodynai.


\subsectionnonum{Darbo tikslas}

Šio tyrimo tikslas - ištirti ir išanalizuoti galimybes internetinės kameros pagalba versti gestų kalbą, taip padedant ne tik gestakalbiams tarpusavyje, bet ir žmonėms, nesuprantantiems gestų kalbos bendrauti su gestakalbiais tam pasitelkiant technologijas. Galiausiai, taip suteikiant šiems žmonėms pilnavertį gyvenimą bendraujant su kitais. Šiuo tyrimu siekiama apžvelgti ir įvertinti ar naudojantis įprasta internetine kamera įmanoma paversti gestų kalbą rašytiniu tekstu ar net garsine kalba ir lygiai taip pat versti rašytinę ar garsinę kalbą į gestų kalbą. Taip pat siekiama, kad vėliau būtų sukurtas visiems gestakalbiams prieinamas produktas ar programinė įranga, kurią kiekvienas įsidiegęs į savo įrenginį - kompiuterį, mobilųjį telefoną ar planšetinį kompiuterį galėtų naudotis šiuo vertėju. Vėliau tai galėtų tapti ir mokomąja gestų kalbos priemone. 
%Šiuo metu yra gaminamas vienas iš tokių produktų, tačiau tai yra atskiras įrenginys, turintis įmontuotą kamerą, kuri be vaizdo taip pat fiksuoja ir atstumą iki tam tikrų objektų (šiuo atveju rankos), tačiau produkto kūrėjai sako, jog jų įrenginys galės versti gestų kalbą į anglų ir kitas kalbas ir lygiai taip pat versti įprastą kalbą į rašytinę kalbą. Plačiau: \textit{http://www.motionsavvy.com/}

\subsectionnonum{Naudojamos priemonės}
\begin{enumerate}
	\item Programavimo kalba Python;
	\item Vaizdų apdorojimo įrankis OpenCV;
	\item Matematinių skaičiavimų biblioteka NumPy;
	\item Įrankių moksliniams tyrimams biblioteka SciPy;
	\item Savaime apsimokančių sistemų biblioteka scikit-learn;
	\item Neuroninių tinklų aplikacijų programavimo sąsaja Keras.
\end{enumerate}

\subsectionnonum{Tyrimo eiga}
Šiame darbe bus nagrinėjamos amerikiečių anglų ir lietuvių gestų kalbos.
\begin{enumerate}
	\item Susipažinimas su gestų kalba ir jos problematika;
	\item Susipažinimas su kelių tipų apmokymo sistemomis;
	\item Praktinis pritaikymas.
\end{enumerate}

%Įvade apibūdinamas darbo tikslas, temos aktualumas ir siekiami rezultatai.
%Darbo įvadas neturi būti dėstymo santrauka. Įvado apimtis 1–2 puslapiai.

\section{Teorija}
Šiame skyriuje bus aprašoma teorija apie apsimokančias sistemas ir neuroninius tinklus.

\subsection{Apsimokančios sistemos}

\textbf{Apsimokančios sistemos} (\textit{angl. machine learning}) - tai mokslas apie tai, kaip kompiuterius užprogramuoti taip, jog jie patys darytų sprendimus be žmogaus įsikišimo neužprogramuojant kiekvienos galimos situacijos. Kitais žodžiais tariant, leisti kompiuteriui pačiam nuspręsti kaip elgtis esant tam tikroms aplinkybėms. Savaime apsimokančios sistemos yra didelis žingsnis į priekį norint sukurti dirbtinį intelektą.

Savaime apsimokančių sistemų ir jų algoritmų sukūrimo dėka gatvėmis pradėjo važinėti patys save vairuojantys automobiliai (\textit{angl. self-driving cars}) arba dar kitaip vadinamos autonominės transporto priemonės. Įvairūs paieškos varikliai tokie kaip „Google“ ar „Yahoo“ taikydami šiuos alogirtmus naudotojams rodo kiekvienam asmeniškai sugeneruotą turinį. Taip pat reikėtų paminėti ir kalbos atpažinimo sistemas tokias kaip „Siri“ ar „Google Assistant“, kurios iš joms duotų komandų atlieka tam tikrus veiksmus.

\subsection{Neuroniniai tinklai}
\textbf{Neuronas} (\textit{arba - nervinė ląstelė}) - pagrindinės nervų sistemos ląstelės, sukuriančios ir/arba perduodančios elektrocheminius impulsus.



Žmogaus smegenys yra sudėtingas, nelinijinis ir paralelinis kompiuteris\cite{Hay09}, kurias sudaro neuronai. Vienas neuronas vienu metu jungiasi su daugybe kitų neuronų per dendritus, ant kurių yra daug sinapsių, per kurias ateina informacija iš kitų neuronų. Dendritus paprasčiau galima pavadinti kaip informacijos priimėjais. Todėl vienas neuronas gali sudaryti iki 100000 sinapsių. Kiekviena sinapsė gali būti jaudinanti arba slopinanti. Visas šis mechanizmas dar nadinamas \textbf{neuroniniu tinklu} (\textit{angl. Neural network}).

Vienas neuronas priima informaciją per dendritus, tuomet pats neuronas nusprendžia ar bus siunčiama informacija į kitus neuronus ir kokia ji bus siunčiama (\textit{žr. \ref{img:neuron_structure} pav.})

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\linewidth]{img/neuron-structure}
	\caption[]{Neuroninio tinklo struktūra\footnotemark}
	\label{img:neuron_structure}
	%https://www.tutorialspoint.com/artificial_intelligence/artificial_intelligence_neural_networks.htm
\end{figure}
\footnotetext{\url{https://www.tutorialspoint.com/artificial_intelligence/artificial_intelligence_neural_networks.htm/}}

Remiantis šiais principais buvo sukurti dirbtiniai neuroniniai tinklai.


\subsubsection{Dirbtiniai neuroniniai tinklai}
\textbf{Dirbtinis neuroninis tinklas} (\textit{angl. Artificial neural network}) - struktūra, skirta apdoroti dideliam kiekiui informacijos, sukurta rementis žmogaus nervų sistemos veikimo principu. Kitais žodžiais tariant, skaitmenizuota žmogaus smegenų veikla.

Neuronai dirbtiniame neuroniniame tinkle yra sujungti jungtimis. Taip jie tarpusavyje komunikuoja perduodami vienas kitam informaciją. Kiekvienas neuronas gali priimti atėjusią informaciją, ją apdoroti ir perduoti kitam neuronui. Kiekviena jungtis turi savo svorį, pagal kurį pasirenkama, į kurį neuroną turi būti perduodama informacija toliau. Šių jungčių svorius galime įvertinti naudodamiesi apsimokančių sistemų pagalba. 

\ref{fig:ann} pav. pateikiama supaprastinta schema, kaip veikia dirbtiniai neuroniniai tinklai:

\begin{figure}[H]
	\centering
	\tikzset{%
		every neuron/.style={
			circle,
			draw,
			minimum size=1cm
		},
	}
	
	\begin{tikzpicture}[x=1.5cm, y=1.5cm, >=stealth]
	\centering
	
	\foreach \m/\l [count=\y] in {1,2,3}
	\node [every neuron/.try, neuron \m/.try] (input-\m) at (0,1.9-\y) {};
	
	\foreach \m [count=\y] in {1,2,3,4}
	\node [every neuron/.try, neuron \m/.try ] (hidden-\m) at (2,2.5-\y) {};
	
	\foreach \m [count=\y] in {1,2}
	\node [every neuron/.try, neuron \m/.try ] (output-\m) at (4,2.3-\y*1.6) {};
	
	\foreach \i in {1,...,3}
	\foreach \j in {1,...,4}
	\draw [->] (input-\i) -- (hidden-\j);
	
	\foreach \i in {1,...,4}
	\foreach \j in {1,...,2}
	\draw [->] (hidden-\i) -- (output-\j);
	
	\foreach \l [count=\x from 0] in {Įeigos, Paslėptasis, Išeigos}
	\node [align=center, above] at (\x*2,2) {\l \\ sluoksnis};
	\end{tikzpicture}
	\caption{Dirbtinio neuroninio tinklo pavyzdys} \label{fig:ann}
\end{figure}

\subsubsection{Konvoliuciniai neuroniniai tinklai}
\textbf{Konvoliuciniai neuroniniai tinklai} (\textit{angl. Convolutional neural network}) (\textit{toliau - KNT}) - specilios rūšies „Feed-forward“ neuroniniai tinklai, kurie reamiasi tuo pačiu dirbtinių neuroninių tinklų (\textit{žr. \ref{fig:ann} pav.}) principu. Šie tiklai yra skirti atpažinti objektus. Apmokant KNT, pagrindinis principas, kaip ir raktinis šių tinklų žodis, yra konvoliucija. Tai tarsi filtrai, kurie išskaido kadrą į dalis, pritaiko įvairius filtrus ir gliausiai randa pasikartojančius įvairiuose kadruose esančius požymius. Tokius kaip, ratas, langai ar pan., o šio tyrimo atveju - rankos, delnai, pirštai, jų padėtis ir kt.

Šiame tyrime bus aptariamas ReLU principas, nes konvoliuciniai neuroniniai tinklai, kurie remiasi ReLU principu yra kelis kartus greitesni, nei tie, kurie remiasi kitais principais, pavyzdžiui, tanh \cite{NIPS2012_4824}. Kuomet kadrui yra pritaikoma konvoliucija (sudauginami visi kadro taškai su konvoliucine matrica), pritaikomas ReLU principas, kuris visus neigiamus skaičius paverčia į 0. Telkimo (\textit{angl. pooling}) fazėje, kadras yra sumažinamas (\textit{žr. \ref{img:cnn} pav.}). Plačiau šie etapai bus aptarti 3.3 skyriuje.

\begin{figure}[H]
	\centering
	\includegraphics[width=.8\linewidth]{img/cnn}
	\caption[]{Konvoliucinių neuroninių tinklų schema\footnotemark}
	\label{img:cnn}
\end{figure}
\footnotetext{\url{http://yann.lecun.com/exdb/lenet/}}


\subsubsection{Rekurentiniai neuroniniai tinklai}
\textbf{Rekurentiniai neuroniniai tinklai} (\textit{angl. Recurrent neural network}) - tai dirbtinis neuroninis tinklas, kuris saugo informaciją apie praeituose žingsniuose (neuronuose) atliktus veiksmus ar skaičiavimus. Remiantis rekurentinių tinklų savybe galima naudoti jau surinktą informaciją, o šiuo atveju tai labai pasitarnautų, kuomet gestas nėra statinis. Todėl kiekviename kadre jeigu fiksuojama kažkokio statinio gesto reikšmė, tai sujungus jas į rekurentinį neuroninį tinklą galima atpažinti dinaminius gestus.


\begin{figure}[H]
	\centering
	\includegraphics[width=.8\linewidth]{img/rnn}
	\caption[]{Rekurentinių neuroninių tinklų schema\footnotemark}
	\label{img:rnn}
\end{figure}
\footnotetext{\url{http://colah.github.io/posts/2015-08-Understanding-LSTMs/}}
\begin{itemize}
	\item \textit{x\textsubscript{t}} - įeiga momentu \textit{t};
	\item \textit{h\textsubscript{t}} - išeiga momentu \textit{t};
	\item \textit{A\textsubscript{t}} - būsena momentu \textit{t}.
\end{itemize}


\section{Gestų kalba}
\subsection{Gestų kalbos skirstymas}
Gestų kalba susideda iš dviejų dalių - statinių ir dinaminių ženklų. Gestų kalboje kiekviena kalba turi savo abėcėlę. Statiniais ženklais atvaizduojama didžioji abėcėlių raidžių dalis. O dinaminiais - žodžiai ir kai kurios gestų abėcėlių raidės. \textit{Pavyzdžiui}, amerikiečių gestų kalbos abėcėlėje J ir Z raidės atvaizduojamos dinaminiais judesiais (\textit{žr. \ref{img:asl_alphabet} pav.}), o lietuvių - jau minėtosios J ir Z raidės bei Ą, D, Į, K ir kt. (\textit{žr. \ref{img:lsl_alphabet} pav.})


\begin{figure}[H]
	\centering
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/asl_alphabet}
		\caption[a]{Amerikiečių gestų kalbos abėcėlė\footnotemark}
		\label{img:asl_alphabet}
		%http://lifeprint.com/asl101/topics/wallpaper1.htm
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.5\linewidth]{img/lsl_alphabet}
		\caption[b]{Lietuvių gestų kalbos abėcėlė\footnotemark}
		\label{img:lsl_alphabet}
		%https://www.kspvm.lm.lt/images/naujienos/2016-2017/kurciuju-filmuko-laimejimas/img/lt-gestu-abecele.jpg
	\end{minipage}
\end{figure}
\footnotetext{\url{http://lifeprint.com/asl101/topics/wallpaper1.htm}}
\footnotetext{\url{http://gestai.ndt.lt/pirstu-abecele}}
\subsection{Problematika}
Norint atpažinti gestus, paversti juos į raides, žodžius ar sakinius susiduriama su problemomis, kurios susijusios tiek su statinių, tiek su dinaminių gestų atpažinimu.

\subsubsection{Statinių ženklų problematika}
Pagrindinės problemos iškylančios atpažįstant statinius gestų kalbos ženklus yra:
\begin{enumerate}
	\item Kiekvienos kalbos abėcėlę sudaro skirtingas raidžių (statinių ženklų) skaičius. \textit{Pavyzdžiui}, lietuvių kalbos abėcėlę sudaro 32 ženklai, o amerikietišką - 26; 
	\item Gestų panašumai. \textit{Pavyzdžiui}, raidės A, E, N, S, T yra atvaizduojamos sugniaužtus kumštį, o net trijose iš jų (A, E ir S) skiriasi tik nykščio padėtis;
	\item Kampas, kuris susidaro atpažįstant gestą. \textit{Pavyzdžiui}, kai A raidė rodoma ne iš priekio, o iš šono;
	\item Apšvietimas. \textit{Pavyzdžiui}, gestų atpažinimas esant prieblandai ir dienos šviesai.
\end{enumerate}
\subsubsection{Dinaminių ženklų problematika}
Pagrindinės problemos iškylančios atpažįstant dinaminius gestų kalbos ženklys yra:
\begin{enumerate}
	\item Nauji gestų kalbos žodžiai. \textit{Pavyzdžiui}, kiekvienas uraganas turi savo pavadinimą, todėl tai gali reikšti naujo gesto atsiradimą; 
	\item Gesto kelios reikšmės. \textit{Pavyzdžiui}, vienas gestas gali turėti kelias reikšmes, kaip kad lietuvių kalboje vienas žodis „kasa“ gali turėti net tris skirtingas reikšmes;
	\item Kampas, kuris susidaro atpažįstant gestą. \textit{Pavyzdžiui}, kai rodantysis žmogus stovi šiek tiek šonu;
	\item Žodžių apjungimas į vieną sakinį. \textit{Pavyzdžiui}, keli gestai einantys vienas po kito gali reikšti vieną žodį, tačiau tuo pačiu būti panašūs į vieną gestą, kuris jau reikš tik vieną žodį.
\end{enumerate}

\section{Sistemos apmokymas}
Norint, jog sistema atpažintų gestus, svarbiausia ją apmokyti, ką reiškia tam tikri gestai. Tam galime išnaudoti kadrus (\textit{angl. frame}) ir savaime apsimokančių sistemų galimybes. Tad reiktų imti vieną kadrą ir jį paversti į kompiuteriui suprantamą kalbą. 

\subsection{Kadro transofrmacija}
Kiekvienas kadras yra sudarytas iš \textit{h * w * c} taškų (\textit{angl. pixels}). Čia, \textit{h} - aukštis (\textit{angl. height}), \textit{w} - plotis (\textit{angl. width}), \textit{c} - spalva (\textit{angl. color}), susidedanti iš RGB spalvų paletės. RGB spalvų paletė - tai trijų - raudonos, žalios ir mėlynos - spalvų paletė, kuri yra ypatinga tuo, jog kiekviena spalva, kurią mato žmogus, susideda būtent iš šių trijų spalvų, varijuojant jų ryškumu. 0 - spalva nenaudojama, o 255 - spalva naudojama pilnai ryškiai. Tad kiekvieną kadrą galima išskirti į šių trijų spalvų sluoksnius.

\subsection{Sistemos apmokymas, naudojantis įprastinėmis sistemomis}
\textbf{Kompiuterio vaizdų atpažinimo sistemos} (\textit{angl. computer vision}) - sistemos, kurias galima apmokyti atpažinti įvairius objektus, dar žinomos kaip \textit{CV}.

Šiame poskyryje bus nagrinėjamos OpenCV atviro kodo (\textit{angl. open-source}) vaizdų atpažinimo aplikacijų programavimo sąsajoje esančios galimybės ir algoritmai.

\subsubsection{Kadro apdorojimas naudojant Sobel branduolį}
\textbf{Sobel branduolys} (\textit{angl. Sobel operator}) - vaizdų apdorojimo algoritmas, skirtas skirtas paversti kadrą į kontūrų žemėlapį.

Šis branduolys naudojasi šiomis funkcijomis, kad konvertuotų vaizdą į kontūrus:

\begin{equation}\label{eq:sobelgx}
	G_x = 
	\begin{bmatrix}
	+1 & 0 & -1 \\
	+2 & 0 & -2 \\
	+1 & 0 & -1
	\end{bmatrix} * A
\end{equation}
	
\begin{equation}\label{eq:sobelgy}
	G_y = 
	\begin{bmatrix}
	+1 & +2 & +1 \\
	0 & 0 & 0 \\
	-1 & -2 & -1
	\end{bmatrix} * A
\end{equation}

\begin{equation}\label{eq:sobelg}
G = \sqrt{G_x^2 + G_y^2}
\end{equation}

\begin{figure}[H]
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/A}
		\caption{Orginalus paveikslėlis}
		\label{img:a-sign}
		%http://lifeprint.com/asl101/topics/wallpaper1.htm
	\end{minipage}\hspace{\fill}%
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/A-sobelX}
		\caption{Pritaikyta \textit{G\textsubscript{x}}}
		\label{img:a-sobelX}
		%https://www.kspvm.lm.lt/images/naujienos/2016-2017/kurciuju-filmuko-laimejimas/img/lt-gestu-abecele.jpg
	\end{minipage}\hspace{\fill}%
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/A-sobelY}
		\caption{Pritaikyta \textit{G\textsubscript{y}}}
		\label{img:a-sobelY}
		%https://www.kspvm.lm.lt/images/naujienos/2016-2017/kurciuju-filmuko-laimejimas/img/lt-gestu-abecele.jpg
	\end{minipage}\hspace{\fill}%
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/A-sobel}
		\caption{Pritaikyta \textit{G}}
		\label{img:a-sobel}
		%https://www.kspvm.lm.lt/images/naujienos/2016-2017/kurciuju-filmuko-laimejimas/img/lt-gestu-abecele.jpg
	\end{minipage}\hspace{\fill}%
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/A-black}
		\caption{Be fono}
		\label{img:a-black-sign}
		%https://www.kspvm.lm.lt/images/naujienos/2016-2017/kurciuju-filmuko-laimejimas/img/lt-gestu-abecele.jpg
	\end{minipage}\hspace{\fill}%
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/A-white}
		\caption{Dviejų spalvų}
		\label{img:a-white-sign}
		%https://www.kspvm.lm.lt/images/naujienos/2016-2017/kurciuju-filmuko-laimejimas/img/lt-gestu-abecele.jpg
	\end{minipage}
\end{figure}

Prieš kadrui taikant Sobel funkcijas, reikia jį paruošti. Kadangi Sobel funkcijos ima matricas sudarytas iš \textit{3 $\times$ 3} skaičių, todėl reikia sušvelninti šalia esančius skaičius, tam jog jos rastų tikruosius kontūrus. Tą padaryti lengviausia uždedant kadrui, pavyzdžiui, 5\% miglą (\textit{angl. blur}). Uždėti miglą reikia tam, jog sumažintume triukšmą (\textit{angl. noise}) kontūrams. 

Toliau, atiduodant kadrą Sobel funkcijoms, kadras yra konvertuojamas į skaičių masyvą, kur kiekvienas taškas turi savo skaičių – spalvos kodą. Tuomet norint rasti visus kontūrus esančius kadre, taikome šiuos veiksmus:

\begin{enumerate}
	\item Einame per visus taškus esančius kadre ir taikome \ref{eq:sobelgx} formulę, kur A - kiekvienas \textit{3 $\times$ 3} kadro taško spalvos mastyvas. Gauname \ref{img:a-sobelX} paveiksle pavaizduotą vaizdą;
	\item Einame per visus taškus esančius kadre ir taikome \ref{eq:sobelgy} formulę, kur A - kiekvienas \textit{3 $\times$ 3} kadro taško spalvos mastyvas. Gauname \ref{img:a-sobelY} paveiksle pavaizduotą vaizdą;
	\item Apskaičiuojame dabartinio taško tikrąją reiškę taikydami \ref{eq:sobelg} formulę. Gauname \ref{img:a-sobel} paveiksle pavaizduotą vaizdą.
\end{enumerate}

Po šių žinsnių yra gauta matrica taškų, kuriose keičiasi spalva. Dabar reikia išimti tuos taškus, kurie yra, pavyzdžiui, ta pati balta spalva, tik kitokio atspalvio. Tam įgyvendinti lengviausia pasitelkus matricos vidurkį ir atmetus visus taškus, kurie yra mažesni už vidurkį. Kitaip tariant, išimant mažo skirtumo taškus. Po šių veiksmų lieka tik tie taškai, kurie jau turėtų priklausyti gesto kontūrui.

Ieškant kontūro taip pat reikėtų atmesti ir tuos kontūrus, kurie, pavyzdžiui, neužima daugiau nei 5\% viso ploto ir tuomet nubrėžti kontūrą.

Kitas žingsnis – paversti kadrą į kompiuteriui suprantamą ir kuo paprastesnę kalbą. Turėdami kontūrus, galime kadrą paversti į dvispalvį kadrą, kur viskas, kas yra kontūre bus baltos spalvos, o viskas kas už kontūro ribų – juodos. Tam įgyvendinti reiktų pasidaryti kaukę (\textit{angl. mask}), kurioje viskas, kas už kontūro ribų bus juodos spalvos, tai kas mūsų atveju yra fonas (\textit{žr. \ref{img:a-black-sign} pav.}), o paskui ištrinti tai, kas yra kontūre ir padaryti baltos spalvos, tai kas mūsų atveju bus ženklas (\textit{žr. \ref{img:a-white-sign} pav.}).

Paskutinis žingsnis – prieš apmokant modelį reikia kadrą paversti duomenimis, iš kurių modelis galėtų mokytis. Šioje vietoje buvo pasirinktas plačiausiai naudojamas metodas - kadrą paversti į skaičių matricą, kur balta spalva atitinka 255, o juoda - 0. Ši konvertacija pasirinkta pagal spalvų kodus. Jau pavertus kadrą į skaičių matricą, suplokštiname ją, kad gautume vienmatę matricą. Ir galiausiai į vieną bendrą duomenų rinkmeną (\textit{angl. file}) surašome duomenis tokia seka: pirmas eilutės langelis - gestą atitinkanti abėcėlės raidė, o visi likę šios eilutės langeliai užpildomi vienmatės kadro matricos duomenis skaičių pavidalu, apie kuriuos buvo kalbėta šios pastraipos pradžioje.

\subsubsection{Apsimokančių sistemų apmokymas iš Sobel branduoliu apdoroto kadro}
Turėdami rinkmeną, kurioje yra surašyti visi apmokymams skirtų kadrų duomenys, aptarsime, kaip iš šių duomenų apmokyti sistemą.

Šiame poskyryje aptarsime keletą objektams atpažinti populiarių technikų, kuriomis remiantis galima apmokyti sistemą atpažinti gestus.

Aptarsime visas technikas pasinaudodami ASL abėcėlės aibe, kurioje yra 24 statiniai gestai.

\begin{equation}\label{eq:z}
	z = \theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1^2+\theta_4x_1x_2+...
\end{equation}

\ref{eq:z} formulė apibrėžia, kaip bus apskaičiuojamas parametras \textit{z}, kai norima susidaryti pasirinktos formos plotą, pagal kurį gestas priklausys arba nepriklausys išmoktai abėcėlės raidei. \textit{x\textsubscript{1}} ir \textit{x\textsubscript{2}} yra koordinačių ašys, kuriose yra išsidėstę taškai.

\subsubsubsection{Logistinės regresijos algoritmas}

\textbf{Logistinės regresijos algoritmas} dar žinoma kaip „logistic regression“ algoritmas. Tai – vienas populiariausių šiuo metu naudojamų klasifikavimo algoritmų.

\begin{equation}\label{eq:lr1}
	0 \leq h_\theta^i(x) \leq 1; i = 1, 2, ..., 24
\end{equation}

Remiantis \ref{eq:lr1} formule, apsibrėžiama, jog tikimybės kiekvienai raidei bus ne mažesnės nei 0 ir ne didesnės nei 1, o \textit{i} pasako kelinta raidė tyrinėjama, kur, tarkime, A = 1, B = 2, ir t.t.


\begin{equation}\label{eq:lr2}
	h_\theta^i(x) = P(y=i | x; \theta)
\end{equation}

Remiantis \ref{eq:lr2} formule, apsibrėžiama tikimybės formulė, kuriai kaip parametras paduodamas gesto numeris (tarkime, kad raidė A = 1, B = 2 ir t.t.), bei bus naudojamasi parametrais $\theta$, kur  $\theta$ - svorių vertės, kuriomis remiantis apskaičiuojama tikimybė 
\textit{P}. $\theta$ reikšmes savaime apsimokančios sistemos apsiskaičiuoja skirtingais algoritmais, todėl šiame darbe jie nagrinėjami nebus.

\begin{equation}\label{eq:lr3}
	h_\theta(x)= g(z)
\end{equation}


Remiantis \ref{eq:lr3} formule, galima apsibrėžti ne tik tiesės atskyrimą (pagal įprastinę šios formulės reikšmę), bet ir įvairias formas, kaip šiuo nagrinėjamu atveju, tarkime, delno formą. 

\begin{equation}\label{eq:lr4}
	h_\theta(x) = \frac{1}{1+e^{-z}}
\end{equation}

Galiausiai, \ref{eq:lr4} formulėje galime matyti, jog tikimybė yra apskaičiuojama remiantis \ref{eq:lr3} formulėje apsibrėžtos formos pavidalu.

\subsubsubsection{Linijinis palaikančiųjų vektorių algoritmas}

\textbf{Linijinis palaikančiųjų vektorių algoritmas} dar žinomas kaip „Linear Support Vector Machine“ algoritmas.

Iš esamų duomenų aibės taškų, šiuo atveju – skirtingų gestų raidžių taškų, yra sudaroma matrica, kurioje tarp skirtingų gestų yra nubrėžiamas vektorius, kuris nusako, kurioje vietoje bus traktuojamas vienas gestas, kurioje - kitas. Iki vektoriaus yra parenkamas didžiausias galimas atstumas nuo artimiausių prie vektoriaus esančių duomenų taškų. 

Pats principas $\theta$ parinkimui yra labai panašus kaip loginėje regresijoje, bei \textit{z} yra paskaičiuojama pagal tą pačią formulę.

Šis metodas yra geresnis, kai yra ganėtinai didelis skirtumas tarp duomenų aibės taškų ir lengvai nubrėžiami vektoriai, nes nesikerta duomenų aibės. Dar vienas šio metodo privalumas yra tas, jog nubrėžus vektorių esant didžiausiam atstumui tarp duomenų taškų, esančių arčiausiai vektoriaus, ganėtinai nesunkiai yra nustatoma, kuriai pusei (šiuo atveju gestui), priklauso duotasis taškas.

Tačiau iš kitos pusės, šis metodas nėra ypač lengvai apdorojantis duomenis, jei duomenų aibės yra persidengiančios, todėl gestų kalbos atpažinimo atveju šis metodas nėra labai tikslus, nes gestų duomenų aibės yra persidengiančios didžiaja dalimi ir skiriasi tik pirštų padėtys.

\subsubsubsection{K artimiausių kaimynų algoritmas}

\textbf{K artimiausių kaimynų algoritmas} dar žinomas kaip „k-nearest neighbors“ algoritmas.

Viskas yra suskirstoma į aibes ir pagal tašką ieškomas artimiausias kaimynas arba kaimynų aibė ir, priklausomai nuo to, kurių kaimynų daugiausia, parenkama reikšmė, kokia bus naujojo taško reikšmė.

Šis algoritmas kaip ir prieš tai aptartas linijinis palaikančiųjų vektorių algoritmas nėra idealus pasirinkimas gestų kalbos atpažinimui, nes, tarkime, jei būtų imamas delno vidurio taškas galimi visi 24 variantai ir tik kampuose, žiūrint į atlenktų pirštų skaičių būtų galima nuspręsti, kuris gestas rodomas.


\subsection{Sistemos apmokymas, naudojantis konvoliucinio neuroninio tinklo modeliu}

Prieš apmokant sistemą, naudojantis konvoliucinio neuroninio tinklo modeliu, pirma aptarsime, kas yra konvoliucinis bei telkimo sluoksniai, o vėliau - kaip apmokyti sistemą.

\subsubsection{Konvoliucinis sluoksnis}

Konvoliucinis sluoksnis turi tokius parametrus:
\begin{itemize}
	\item Priima matricą, sudarytą iš \textit{\textbf{W\textsubscript{1} $\times$ H\textsubscript{1} $\times$ D\textsubscript{1}}}, kur \textit{\textbf{W\textsubscript{1}}} - plotis, \textit{\textbf{H\textsubscript{1}}} - aukštis ir \textit{\textbf{D\textsubscript{1}}} - gylis;
	\item Reikalingi papildomi parametrai:
		\begin{itemize}
			\item Filtrų skaičius \textbf{\textit{K}} (dažniausiai naudojamas 2-to laispnis);
			\item Filtro dydis \textbf{\textit{F}} (dažniausiai naudojami 3 $\times$ 3 filtrai);
			\item Žingsnis, per kiek paslenkamas filtras \textbf{\textit{S}};
			\item Papildomas rėmelis duotajai matricai, sudarytas iš 0, \textbf{\textit{P}};
		\end{itemize}
	\item Sudaroma matrica \textit{\textbf{W\textsubscript{2} $\times$ H\textsubscript{2} $\times$ D\textsubscript{2}}}, kur \textit{\textbf{W\textsubscript{2}}} - plotis, \textit{\textbf{H\textsubscript{2}}} - aukštis ir \textit{\textbf{D\textsubscript{2}}} - gylis, kur:
		\begin{itemize}
			\item \textit{\textbf{W\textsubscript{2} = (W\textsubscript{1} – F + 2P)/S + 1}};
			\item \textit{\textbf{H\textsubscript{2} = (H\textsubscript{1} – F + 2P)/S + 1}};
			\item \textit{\textbf{D\textsubscript{2} = K}}.
		\end{itemize}
\end{itemize}

Sluoksnis, kuris pagal filtrą nusprendžia, kokia išeities matricą bus gaunama. Tarkime, jog bus imamas filtras, kuris yra \textit{3 $\times$ 3} matrica. Kadrą, kaip jau buvo minėta teorijos skyriuje, galima išskirstyti į tris skirtingus sluoksnius - raudonos, žalio ir mėlynos spalvos. Pavertus šiuos sluoksnius skaičių matricomis, kur 0 – spalva nenaudojama, o 255 – spalva naudojama pilnai ryškiai, gaunamos matricas, kurios nusako, kaip kiekviename taške ryškiai yra naudojama tam tikra spalva.

Einant taškas po taško per kadro kiekvienos spalvos matricą, imamos \textit{3 $\times$ 3} matricos, kurios yra sudauginamos su filtro matricomis. Taip gaunama matrica, kuria remantis bus galima išskirti savybes.

\textit{Pavyzdys:}

\begin{equation}\label{eq:convl}
	\begin{bmatrix}
	1 & 1 & 0 & 1 & 0 & 1 & 0 \\
	1 & 0 & 1 & 1 & 1 & 0 & 1 \\
	1 & 1 & 0 & 1 & 1 & 0 & 1 \\
	1 & 1 & 0 & 1 & 0 & 1 & 0 \\
	1 & 0 & 1 & 1 & 1 & 0 & 1 \\
	1 & 1 & 0 & 1 & 1 & 0 & 1 \\
	1 & 1 & 0 & 1 & 0 & 1 & 0
	\end{bmatrix}
	*
	\begin{bmatrix}
	1 & 0 & 1 \\
	0 & 1 & 0 \\
	1 & 0 & 1
	\end{bmatrix}
	=
	\begin{bmatrix}
	\colorbox{green}{1} & \colorbox{pink}{3} & 1 & 3 & 1 & 3 & 0 \\
	3 & 2 & 5 & 2 & 4 & 2 & 2 \\
	2 & 4 & 3 & 3 & 3 & 2 & 2 \\
	2 & 4 & 3 & 4 & 2 & 5 & 0 \\
	3 & 2 & 5 & 2 & 4 & 2 & 2 \\
	2 & 4 & 3 & 3 & 3 & 2 & 2 \\
	3 & 2 & 2 & 2 & 1 & 3 & 0
	\end{bmatrix}
\end{equation}

\begin{equation}\label{eq:convl1}
	0*1+0*0+0*1+0*0+1*1+1*0+0*1+1*0+0*1=\colorbox{green}{1}
\end{equation}


\begin{equation}\label{eq:convl2}
	0*1+0*0+0*1+1*0+1*1+0*0+1*1+0*0+1*1=\colorbox{pink}{3}
\end{equation}

\ref{eq:convl} formulėje yra pateikiama \textit{7 $\times$ 7} matrica sudauginama su \textit{3 $\times$ 3} filtru. Panagrinėsime pirmos eilutės pirmąjį (\textit{žr. \ref{eq:convl1} formulę}) ir antrąjį (\textit{žr. \ref{eq:convl2} formulę}) narius. Pirmasis narys yra kampinis skaičius 1. Todėl jis dauginaas su filtro viduriniuoju nariu. Kadangi dabar filtras „išlenda“ iš matricos rėmų, tai įsivaizduojama, kad yra kadro matricai rėmelis, kuris yra sudarytas iš 0. \ref{eq:convl1} ir \ref{eq:convl2} formulėse pirmasis sandaugos narys - \textit{7 $\times$ 7} kadro matricos narys, antrasis - \textit{3 $\times$ 3} filtro matricos narys.

\begin{equation}\label{eq:nuliai}
M=\frac{F-1}{2}
\end{equation}

\ref{eq:nuliai} formulėje yra pateikta, kokio dydžio papildomą išorinį sluoksnį sudarytą iš 0 konvoliuciniai neuroniniai tinklai dažniausiai naudoja. Čia \textit{M} yra sluoksnio plotis pridedamas prie kiekvienos matricos kraštinės, o \textit{F} – filtro matricos dydis. Tai naudojama tam, kad būtų gaunama tokio pačio dydžio matrica, kokia buvo paduota filtrui apdoroti.


\subsubsection{Telkimo sluoksnis}

Telkimo sluoksnis turi tokius parametrus:
\begin{itemize}
	\item Priima matricą, sudarytą iš \textit{\textbf{W\textsubscript{1} $\times$ H\textsubscript{1} $\times$ D\textsubscript{1}}}, kur \textit{\textbf{W\textsubscript{1}}} - plotis, \textit{\textbf{H\textsubscript{1}}} - aukštis ir \textit{\textbf{D\textsubscript{1}}} - gylis;
	\item Reikalingi papildomi parametrai:
	\begin{itemize}
		\item Filtro dydis \textbf{\textit{F}} (dažniausiai naudojami 2 $\times$ 2 filtrai);
		\item Žingsnis, per kiek paslenkamas filtras \textbf{\textit{S}} (dažniausiai naudojams žingsnis - 2);
	\end{itemize}
	\item Sudaroma matrica \textit{\textbf{W\textsubscript{2} $\times$ H\textsubscript{2} $\times$ D\textsubscript{2}}}, kur \textit{\textbf{W\textsubscript{2}}} - plotis, \textit{\textbf{H\textsubscript{2}}} - aukštis ir \textit{\textbf{D\textsubscript{2}}} - gylis, kur:
	\begin{itemize}
		\item \textit{\textbf{W\textsubscript{2} = (W\textsubscript{1} – F)/S + 1}};
		\item \textit{\textbf{H\textsubscript{2} = (H\textsubscript{1} – F)/S + 1}};
		\item \textit{\textbf{D\textsubscript{2} = D\textsubscript{1}}}.
	\end{itemize}
\end{itemize}


Kaip buvo minėta anksčiau, telkimo sluoksnis yra skirtas sumažinti matricą arba kitais žodžiais tariant - kadrą. Telkimo sluoksnis dažniausiai taiko arba vidutinės arba didžiausios reikšmės atrinkimo algoritmą. Kaip pavyzdį paimkime, jog telkimo sluoksnio filtro dydis bus \textit{3 $\times$ 3}. Bus taikomas maksimalaus telkimo principas, kuris nusako, jog paėmus matricos poaibį yra išrenkama didžiausia reikšmė.

\textit{Pavyzdys:}
\begin{equation}\label{eq:poll}
	\begin{bmatrix}
	1 & 3 & 1 & 3 & 1 & 3 \\
	3 & 2 & 5 & 2 & 4 & 2 \\
	2 & 4 & 3 & 3 & 3 & 2 \\
	2 & 4 & 3 & 4 & 2 & 5 \\
	3 & 2 & 5 & 2 & 4 & 2 \\
	2 & 4 & 3 & 3 & 3 & 2
	\end{bmatrix}
	= 
	\begin{bmatrix}
	\colorbox{green}{5} & \colorbox{pink}{4} \\
	5 & 5 
	\end{bmatrix}
\end{equation}
\begin{equation}\label{eq:poll1}
	max(
	\begin{bmatrix}
	1 & 3 & 1 \\
	3 & 2 & 5 \\
	2 & 4 & 3
	\end{bmatrix}
	) = \colorbox{green}{5}
	%1, 3, 1, 3, 2, 5, 2, 4, 3
\end{equation}
\begin{equation}\label{eq:poll2}
	max(
	\begin{bmatrix}
	3 & 1 & 3 \\
	2 & 4 & 2 \\
	3 & 3 & 2
	\end{bmatrix}
	) = \colorbox{pink}{4}
\end{equation}
\ref{eq:poll} formulėje parodyta, kaip pritaikius \textit{3 $\times$ 3} telkimo filtrą gaunama beveik 90\% mažesnė matrica. Mažinimas vyksta taip: imama filtro dydžio matrica, pradėdedant nuo kairiojo viršutinio kampo. Tuomet iš tos matricos išrenkama didžiausia reikšmė (\textit{žr. \ref{eq:poll1} formulę}) ir į naująją matricą ji įrašoma. Tuomet, kadangi jau iš pirmosios \textit{3 $\times$ 3} matricos yra išrinkta didžiausia reikšmė (jei būtų taikomas vidutinės reikšmės atrinkimo algoritmas, būtų imama šios matricos vidutinė reikšmė), imama kitą į dešinę esanti matrica, kuri nepersidengia su pirmąja ir iš jos taip pat išrenkama didžiausia reikšmė (\textit{žr. \ref{eq:poll2} formulę}). Taip filtras yra pritaikomas ir likusioms matricos dalims. Jei filtras „užeina“ už kadro matricos ribų, interpretuojama, jog tose vietose yra 0.

\subsubsection{Apmokymas naudojantis konvoliucinio neuroninio tinklo modeliu}

Kiekvieną sistemą galima apmokyti naudojantis kovoliuciniu neuroniniu tinklo modeliu arba nuodugniai (kuomet apmokomas modelis neturi jokių duomenų) arba dalinai (kuomet pasinaudojama jau veikiančiu modeliu ir nutrinami paskutinį ar paskutinius sluoksnius). Apmokymas nuo pat pradžių dažniausiai reikalauja labai daug laiko resursų, nes užtrunka labai daug laiko. Šis modelis retai naudojamas praktikoje. Dažniausiai naudojamas dalinis apmokymas, pasinaudojus jau sukurtu modeliu galima jį pakartotinai apmokyti norimam rezultatui gauti. 

\textbf{Keras} - giliojo mokymosi biblioteka, naudojama su Theano arba TensorFlow.

\textbf{Theano} - Python biblioteka, skirta darbui su matematinėmis išraiškomis, jų optimizavimui, apibrėžimui, darbui su n-mačiais masyvais.


Naudojantis Keru, sistema buvo apmokyta naudojantis konvoliucinio neuroninio tinklo modeliu. Tai buvo atlikta trimis etapais.

Pasinaudota dvejomis duomenų aibėmis - pirmoji skirta mokymuisi (\textit{data/train}) ir antroji - pasitvirtinimui - validacijai (\textit{data/validation}).

Buvo naudojamasi VGG16 (\textit{Visual Geometry Group}) architektūra (\textit{žr. \ref{img:vgg} pav.}) - konvoliucinių ir telkimo sluoksnių pasikartojančios grandinės. Telkimui naudojama \textit{2 $\times$ 2} matrica, o konvuliacijai - \textit{3 $\times$ 3} matrica.

\subsubsubsection{Pirmasis etapas}
Pirmame etape buvo pritaikytas duomenų dauginimo (\textit{angl. data augmentation}) principas iš duotųjų mokymuisi ir validacijai. Kiekvienam kadrui buvo pritaikytos įvairios modifikacijos apmokant - kadro priartinimas, pakreipimas, horizontalus apvertimas.

%VGG16 achitektūros žingsniai:
%\begin{enumerate}
%	\item Konvuliacija, konvuliacija, telkimas
%	\item Konvuliacija, konvuliacija, telkimas
%	\item Konvuliacija, konvuliacija, konvuliacija, telkimas
%	\item Konvuliacija, konvuliacija, konvuliacija, telkimas
%\end{enumerate}

\subsubsubsection{Antrasis etapas}

Antrajame etape, VGG16 

\subsubsubsection{Trečiasis etapas}

\section{Praktinis gestų kalbos apmokyto modelio pritaikymas}

Praeituose skyriuose buvo aptarta, kokie būdai yra galimi apmokyti sistemą atpažinti gestų kalbą. Šiame skyriuje bus aprašyta, kaip šie aprašyti žingsniai buvo pritaikyti praktiškai.

%Buvo pasirinkta pasidaryti du statinių gestų kalbos atpažinimo modelius. Pirmasis, kuris remiasi įprastinėmis sistemomis, ir antrasis, kuris remiasi konvoliucinio neuroninio tinklo modeliu.

\subsection{Duomenys}
Duomenys (programinis kodas ir kadrai) buvo parsisiųsti iš jau įgyvendintų pavyzdinių gestų kalbos sistemų. Viename iš duomenų rinkinių buvo po 150-250 gesto kadrų kiekvienai raidei (pavyzdys pateiktas \ref{img:a-sign} paveikslėlyje). Taip pat pasinaudojus šių kadrų paprastumu dėl šviesaus ir vienspalvio fono, buvo uždėti skirtingi fonai. 

\begin{figure}[H]
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/A1}
		\caption{A raidės gestas su pakeistu fonu}
		\label{img:a-sign-first}
		%http://lifeprint.com/asl101/topics/wallpaper1.htm
	\end{minipage}\hspace{\fill}%
	\begin{minipage}{.5\textwidth}
		\centering
		\includegraphics[width=.8\linewidth]{img/A2}
		\caption{A raidės gestas su pakeistu fonu}
		\label{img:a-sign-second}
		%https://www.kspvm.lm.lt/images/naujienos/2016-2017/kurciuju-filmuko-laimejimas/img/lt-gestu-abecele.jpg
	\end{minipage}\hspace{\fill}%
\end{figure}

Kiekvienam iš 150-250 kadrų kiekvienai raidei buvo uždėta po du atsitiktinai sugeneruotus fonus. Gesto dydis, spalva, pokrypis keičiamas nebuvo. Todėl buvo sudaryta po ~400 gesto kadrų kiekvienai raidei su 21 skirtingu fonu.

\subsection{Duomenų suskirstymas}

Duomenys buvo suskirstyti į aplankus, kur aplanko pavadinimas rodo raidę, kurią atitinka gestas. Taip buvo sukurti 24 aplankai kiekvienai iš 24 ASL raidžių. Visi duomenys buvo suskirstyti į tris aplankus, kurie buvo skirti apmokymui, patikrinimui ir testavimui. Duomenų imta labai nedaug - apmokymui skirtų gestų kadrų buvo po 500 kiekvienai raidei, patikrinimui - 200 kiekvienai raidei ir dar 100 testavimui skirtų kadrų. Bendrai: 
\begin{equation}
	500*24+200*24+200=17000
\end{equation}

\subsection{Sistemos apmokymas}
Buvo pasirinkta apmokyti sistemą konvoliucinio neuroninio tinklo modeliu. Buvo pasirinkta sistemą apmokyti naudojantis „Keras“ giliojo mokymosi biblioteka, kuri naudojosi „Te“ biblioteka (\textit{plačiau - 3.3.3. skyriuje}).

%\subsubsection{Duomenų suskirstymas}


%\subsection{Atpažinimas naudojant gestų nuotraukas}
%Norint, jog sistema apsimokytų kuo tiksliau, reikia jai duoti kuo daugiau duomenų. Sakykime, kad:
%\begin{itemize}
%	\item\textit{a\textsubscript{ik}} - \textit{i}-toji \textit{k}-tosios abėcėlės raidės nuotrauka 
%	\item\textit{a\textsubscript{1k}, a\textsubscript{2k}, ..., a\textsubscript{nk}} - nuotraukų rinkinys, sudarytas iš \textit{n} \textit{k}-tosios raidės nuotraukų
%\end{itemize}
%Tuomet, turėdami \textit{n * k} nuotraukų, kuriuose vaizduojami gestų abėcėlės gestai, turime, jog tiek eilučių duomenų turėsime gestams atpažinti. Kuo gestai yra įvairesni prie skirtingų apšvietimų, skirtingų rankų ir pan., tuo tiksliau sistema pati galės vėliau atpažinti gestus.


%\subsection{Atpažinimas naudojant internetinę kamerą}
%Norint atpažinti statinius gestus naudojant internetinę kamerą, vienas iš to būdų yra naudotis \textit{BackgroundSubtractorMOG2} klase. Ši klasė remiasi Gauso maišos priekinio plano/fono atskyrimo algoritmu



%\section{Pagrindinė tiriamoji dalis}
%Pagrindinėje tiriamojoje dalyje aptariama ir pagrindžiama tyrimo metodika;
%pagal atitinkamas darbo dalis, nuosekliai, panaudojant lyginamosios analizės,
%klasifikacijos, sisteminimo metodus bei apibendrinimus, dėstoma sukaupta ir
%išanalizuota medžiaga.
%
%\subsection{Poskyris}
%Citavimo pavyzdžiai: cituojamas vienas šaltinis \cite{PvzStraipsnLt}; cituojami
%keli šaltiniai \cite{PvzStraipsnEn, PvzKonfLt, PvzKonfEn, PvzKnygLt, PvzKnygEn,
%PvzElPubLt, PvzElPubEn, PvzMagistrLt, PvzPhdEn}.
%
%\subsubsection{Skirsnis}
%\subsubsubsection{Straipsnis}
%\subsubsection{Skirsnis}
%\section{Skyrius}
%\subsection{Poskyris}
%\subsection{Poskyris}

\sectionnonum{Išvados}
Išvadose ir pasiūlymuose, nekartojant atskirų dalių apibendrinimų,
suformuluojamos svarbiausios darbo išvados, rekomendacijos bei pasiūlymai.

\printbibliography[heading=bibintoc] % Literatūros šaltiniai aprašomi
% bibliografija.bib faile. Šaltinių sąraše nurodoma panaudota literatūra,
% kitokie šaltiniai. Abėcėlės tvarka išdėstoma tik darbe panaudotų (cituotų,
% perfrazuotų ar bent paminėtų) mokslo leidinių, kitokių publikacijų
% bibliografiniai aprašai (šiuo punktu pasirūpina LaTeX). Aprašai pateikiami
% netransliteruoti.

\appendix  % Priedai
% Prieduose gali būti pateikiama pagalbinė, ypač darbo autoriaus savarankiškai
% parengta, medžiaga. Savarankiški priedai gali būti pateikiami kompiuterio
% diskelyje ar kompaktiniame diske. Priedai taip pat vadinami ir numeruojami.
% Tekstas su priedais siejamas nuorodomis (pvz.: \ref{img:mlp}).

\section{VGG16 architektūra}
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{img/vgg-architecture}
    \caption{VGG16 architektūros modelis}   % Antraštė įterpiama po paveikslėlio
    \label{img:vgg}
\end{figure}
%
%
%\section{Eksperimentinio palyginimo rezultatai}
%% tablesgenerator.com - converts calculators (e.g. excel) tables to LaTeX
%\begin{table}[H]\footnotesize
%  \centering
%  \caption{Lentelės pavyzdys}    % Antraštė įterpiama prieš lentelę
%  {\begin{tabular}{|l|c|c|} \hline
%    Algoritmas & $\bar{x}$ & $\sigma^{2}$ \\
%    \hline
%    Algoritmas A  & 1.6335    & 0.5584       \\
%    Algoritmas B  & 1.7395    & 0.5647       \\
%    \hline
%  \end{tabular}}
%  \label{tab:table example}
%\end{table}

\end{document}
